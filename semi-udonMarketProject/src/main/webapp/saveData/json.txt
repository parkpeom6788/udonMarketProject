MSA는 was가 여러개 있어서 서로 연동해서 하나의 서비스를 만들어낸다 비용이 많이 든다 
객체가 커져서 하나의 서버가 된다 
MVC 
View resonse 전담
Model business DAO -> singleton 적용
Controller request 제어 , view 와 Model 를 제어 
모든 클라이언트의 요청을 하나의 진입점으로 처리 Front Controller Pattern

CheckLoginInterceptor : Front 에서 인증체크 
					비인증 상태 
	인증이 필요한 사용자가 비인증 상태이면 로그인 폼 페이지로 이동 
						Controller		Model		DB
FrontControllerServlet - HandlerMapping - Controller 인터페이스
										   ㅣ 	 		ㅣ
										FindId	   UpdateMember		
										인증체크로직	인증체크로직
				업데이트 되면 인증체크 로직이 다 바껴야되는 문제가 발생....
				그래서 미리 FrontControllerServlet 에서 
				CheckLoginInterceptor 에서 각 Controller 인증체크로직을 반복처리하지 않고
				인증체크 일괄처리 한다 
				FrontControllerServlet에 true 이면 해주고 false 이면 안하고
				CheckLoginInterceptor 에서 가로채서 처리 
				
FrontControllerServlet - CheckLoginInteceptor
		
	doDispatch() - 클라이언트가 오면 누구한테 연결시켜준다
	보안 , 인증 담당
		false : 진행 불가 인증 필요 서비스 인데 비인증 상태 
		true : 진행 인증상태
	
	if(interceptor 결과가 false 이면 ) {
		response.sendRedirect(로그인폼경로)
		return; // 메서드 종료 - 응답을하고 끝내버린다 
	}
	네이밍룰 : 이름의 규칙을 정한다.
	공개되는거라면 public 이라고 짓든가 
	패키지명.kosta.model 로 가자 로도 할수 있다. 규칙을 안정하면 중구난망이 된다.
	
	모든 client 요청을 하나의 진입점으로 모아서 FrontControllerServlet
	:인코딩 , 예외처리 , 보안(인증) 
	
	<-> HandlerMapping <-> Controller  <-> Model <-> DB
		l	l				l	l
		l	l			FindController
		l	l			UpdateController
		l	l			
		1	1				
	checkLogin Interceptor 		
	인증체크로직이 필요없게 된다.
    반복작업을 피함으로서 생산성을 높인다
		
	AJAX
	비동기 : 요청해놓고 내 할일 한다 
	동기적 페이지는 페이지가 바뀌어서 기존의 작업 의미가 없어진다. 
	
	FrontControllerServlet(요청진입,공통정책) 			HandlerMapping(컨트롤러 생성전담)				Controller(컨트롤러 캡슐화)
			인코딩																			
			예외처리->error.jsp																		FindController
			보안(인증체크) - 인터셉터 checkLoginIntercepter -> 인증이 필요한 서비스 대상으로 비인증상태일 경우 로그인 폼으로 이동 , 프로그램이 견고해 진다.  -> 세미때 여유가 있을때 하자 											
			데이터 수집 - RANK OVER(우선순위) ,로그인 성향 어떤상품을 걸어두는지 타켓 마켓팅 
			
			Ajax - 내공이 쌓이게되면 자연스럽게 이해됨 - 아이디 중복 확인 , 게시물당 좋아요 
			3시에는 깃 연습 토의시간,스터디시간(인터셉터는 토의시간에서 제외해도됨 ,ajax 정규화공부를 많이 해야 모델링할때 도움됨)
			
---------------------------------------------
GIT 
step1 가입 로그인 토큰
step2 remote repository 
	  gitignore 설정
	  
git ingit 대상을 제외하겠다 저장할때 클래스파일이 바뀐다 코드가 하나 바뀌면 충돌 클래스->컴파일 파일이 다르므로 계속 pull? push? 매우 중요하다

jar 파일도 공유하지않는다 - 형상관리 에서 제외시킴 # 추가 
/settings #안해주면 세팅을 다시 해줘야 한다.	  
	  	  
Git step3 clone
		  ide 연결 
step4 share project
	  src/main/java 		-> 파일 까지 생성
	  src/main/resourecs 	-> 파일 까지 생성
	  src/test/java -> 파일까지 생성
	  필수 lib 도 넣는다 
	  
	  이미지 폴더는 이미지들도 넣어야 형상관리 대상에 된다. 
	  
	  index.jsp 도 필수이다.
	  
	  project - clean 깔끔하게 파일정리됨
	  
	  share project 하기전에 index.jsp를 잘뜨는지 실험해본다. 그러고 나서 team -> share project -> 파일에서 x표시가 보이면 -> add to build path 도 해주면 좋음 
	  ?는 형상관리 대상이 안된것이다. -> git stage 열어주면 됨 -> 그러면 무대에 올리긴 형상관리 포함안된  jar 와 java 가 나온다
	  -> commit -> push 한다 
		
			
		commit -> team -> show in history -> commit 한 기록이 다 나와 있다.
		
	  Synchronizied 는 서버와 나와 어떤 상태로 되어있는지 확인 -> 충돌 판단 을 
	  
	  push , pull 
	  
step5 add , commit , push 

↑ 서버에 올려야되는거  ↓ commit 까지 해놓고 pull 받아야 되는거 (버전이 안맞으면 x표시 뜨면서 병합해야함)

브렌치 -> team -> switch to -> new branch 
새로운 브랜치에서 폴더를 add 해서 commit -> push 한 후 
브렌치 -> team -> switch to -> main 브렌치에서 merge 해서 병합할수있다. 

team -> synchronized workspace -> 변화가없다는건 내 브랜치가 최신상태라는것 (항상 main을 -> 최신이 아니면 pull 받아야됨
team -> merge -> member iu 작업한것을 병합할것임 merge 누르면 됨 -> 서버에 push 해주면 내가 iu브랜치에서 작업했던것을 올리게 됨 
 
Ajax JSON
-> java script Object Notation
자바스크립트 객체 표기법
구조화된 데이터 통신을 위해 사용 

Ajax xml 또는 JSON의 필요성 통신용 -> 구조화된 데이터 (vo,dto,set,map) 

			Ajax(필요한 데이터만 응답)
client <---> Server  	
	   ---->
		request
	   <----
		response
"hello"			"hello" -> 단순 텍스트

화면이 대체로 

아이디 ㅁ ----->	"java / 아이유"		
ㅡㅡㅡㅡ
ㅡㅡㅡㅡ
ㅡㅡㅡㅡ
ㅡㅡㅡㅡ  <------ java 와 아이유를 분리해야하는 작업을 해야한다. 
이름 ㅁ

Ajax에  xml , json의 필요성 -> 구조화된 페이지 통신 
							  ㅣ
							회원객체 or 상품리스트 등 
		Ajax		 server  <---> db
	현대	검색 ------>
	르노		request
					일반 문자열메시지로 가능?
					자동차리스트 Car의 List<CarVO>
					XML or JSON 
			<------		 
	사각형 	? 어떻게 					

json object {"name:value" ,"name:value"}
			   id : java    name:아이유
json Array[{ } ,{ }]
		
		[ 는 jsonArray 
		{ } 는 jsonObject
		















